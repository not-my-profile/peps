PEP: 9999
Title: Type stubs for single-file top-level modules
Author: Martin Fischer <martin@push-f.com>
Discussions-To: https://github.com/python/typing/issues/1333
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 09-Jan-2023
Post-History: 09-Jan-2023
Resolution:


Abstract
========

:pep:`561` established a standard to mark that a package includes
type stubs by creating a ``py.typed`` marker file within the package
directory. This PEP introduces an additional standard to support the
provision of type stubs for single-file top-level modules by simply
creating a file named ``{module}.pyi`` in the site-package directory
(where ``{module}`` denotes the name of the respective top-level
module).


Rationale
=========

CPython allows Python libraries to be written in programming languages
other than Python via its C extension API. [1]_ Shared library files
(e.g. ``.so`` files on Linux or ``.pyd`` files on Windows) are usually
distributed in the wheel format, introduced in :pep:`427`.  A binary
distribution can contain both a binary library file as well as type
stubs for the shared library as illustrated in the following example::

    mypackage
    ├── __init__.py
    ├── native.cpython-36m-x86_64-linux-gnu.so
    ├── native.pyi
    └── py.typed

The ``py.typed`` file is a marker file as per :pep:`561`, indicating to
static type checkers to look for the ``native.pyi`` type stub file
within the package directory.  This works fine for mixed packages, which
contain some Python code and some native code, and also for cases where
you want the binary module to be part of the public API under the
namespace of a package (e.g.  ``mypackage.native``).

The approach however does not work as well for cases where you want
the binary module to be the sole top-level API. While this can
technically be achieved by placing the shared library file directly
in the ``site-packages`` directory, :pep:`561` does not foresee a way
to associate a ``.pyi`` type stub file with a shared library file,
residing directly in ``site-packages``.
The standard-compliant workaround for this has been to use the
previously shown file structure and defining a ``__init__.py``
such as the following::

  from ._native import *

  __doc__ = _native.__doc__
  if hasattr(_native, "__all__"):
      __all__ = _native.__all__

Note that in this case the ``native.*`` files have been renamed to
``_native.*`` to indicate that the module is not part of the public API.
While this does work it comes with several disadvantages:

1. You can import ``mypackage._native``.
2. ``_native`` shows up in the documentation generated by documentation
   generators. For example pydoc [2]_ will list ``_native`` under
   PACKAGE CONTENTS and ``help(mypackage.example)`` will tell you that
   ``example`` resides in ``mypackage._native``.
3. ``mypackage.__file__`` now points to the ``__init__.py`` file instead
   of the ``.so`` file, potentially misleading developers into thinking
   the package is implemented in Python.

Specification
=============

For single-file modules residing directly in a ``site-packages``
directory static type checkers should also recognize ``{module}.pyi``
type stub files within the same site-packages directory (where
``{module}`` denotes the name of the respective module).

This makes intermediary ``__init__.py`` that simply reexport everything
from a binary module redundant, allowing the package of the previous
example to simply be distributed as::

  mypackage.cpython-36m-x86_64-linux-gnu.so
  mypackage.pyi

References
==========
.. [1] Building C and C++ Extensions
   (https://docs.python.org/3/extending/building.html)

.. [2] pydoc
   (https://docs.python.org/3/library/pydoc.html)

Copyright
=========

This document has been placed in the public domain.
